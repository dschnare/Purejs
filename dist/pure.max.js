!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Pure=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
'use strict';
var adheresTo, ck, create, isArray, isBoolean, isDefined, isFunction, isNumber, isObject, isPrimitive, isString, isUndefined, mixin, typeOf,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

ck = require('constructor-kit');

create = function(o) {
  var F;
  if (isPrimitive(o)) {
    o = new o.constructor(o);
  }
  F = (function() {
    function F() {
      this.constructor = F;
    }

    return F;

  })();
  F.prototype = o;
  return new F;
};

isString = function(o) {
  return typeof o === 'string' || o instanceof String;
};

isBoolean = function(o) {
  return typeof o === 'boolean' || o instanceof Boolean;
};

isNumber = function(o) {
  return typeof o === 'number' || o instanceof Number;
};

isFunction = function(o) {
  return typeof o === 'function';
};

isPrimitive = function(o) {
  return /string|number|boolean/.test(typeof o);
};

isDefined = function(o) {
  return o !== null && o !== void 0;
};

isUndefined = function(o) {
  return o === null || o === void 0;
};

isArray = function(o) {
  return o instanceof Array || Object.prototype.toString.call(o) === '[object Array]';
};

isObject = function(o) {
  return o === Object(o) && typeof o !== 'function';
};

typeOf = function(o) {
  if (o === null) {
    return 'null';
  }
  if (isArray(o)) {
    return 'array';
  }
  return typeof o;
};

mixin = function() {
  var k, o, obj, objs, v, _i, _len;
  o = arguments[0], objs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (o == null) {
    throw new Error('Expected at least one object as an argument.');
  }
  for (_i = 0, _len = objs.length; _i < _len; _i++) {
    obj = objs[_i];
    for (k in obj) {
      if (!__hasProp.call(obj, k)) continue;
      v = obj[k];
      if (isDefined(obj)) {
        o[k] = obj[k];
      }
    }
  }
  return o;
};

adheresTo = function(o, interfce) {
  var k, v;
  if ((isObject(o) || isFunction(o) || isArray(o)) && (isObject(interfce) || isFunction(interfce) || isArray(interfce))) {
    for (k in interfce) {
      if (!__hasProp.call(interfce, k)) continue;
      v = interfce[k];
      if (interfce[k] === '*') {
        if (o[k] === void 0) {
          return false;
        }
      } else {
        if (!(typeOf(o[k]) === typeOf(interfce[k]) || typeOf(o[k]) === interfce[k])) {
          return false;
        }
      }
    }
    return true;
  }
  return typeOf(o) === typeOf(interfce);
};

module.exports = {
  create: create,
  isString: isString,
  isBoolean: isBoolean,
  isNumber: isNumber,
  isFunction: isFunction,
  isPrimitive: isPrimitive,
  isDefined: isDefined,
  isUndefined: isUndefined,
  isArray: isArray,
  isObject: isObject,
  typeOf: typeOf,
  mixin: mixin,
  adheresTo: adheresTo,
  constructor: {
    create: ck.ck
  }
};

},{"constructor-kit":1}]},{},[2])(2)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwibm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxsaWJcXF9lbXB0eS5qcyIsInB1cmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLG51bGwsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYWRoZXJlc1RvLCBjaywgY3JlYXRlLCBpc0FycmF5LCBpc0Jvb2xlYW4sIGlzRGVmaW5lZCwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1ByaW1pdGl2ZSwgaXNTdHJpbmcsIGlzVW5kZWZpbmVkLCBtaXhpbiwgdHlwZU9mLFxyXG4gIF9fc2xpY2UgPSBbXS5zbGljZSxcclxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbmNrID0gcmVxdWlyZSgnY29uc3RydWN0b3Ita2l0Jyk7XHJcblxyXG5jcmVhdGUgPSBmdW5jdGlvbihvKSB7XHJcbiAgdmFyIEY7XHJcbiAgaWYgKGlzUHJpbWl0aXZlKG8pKSB7XHJcbiAgICBvID0gbmV3IG8uY29uc3RydWN0b3Iobyk7XHJcbiAgfVxyXG4gIEYgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICBmdW5jdGlvbiBGKCkge1xyXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gRjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gRjtcclxuXHJcbiAgfSkoKTtcclxuICBGLnByb3RvdHlwZSA9IG87XHJcbiAgcmV0dXJuIG5ldyBGO1xyXG59O1xyXG5cclxuaXNTdHJpbmcgPSBmdW5jdGlvbihvKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fCBvIGluc3RhbmNlb2YgU3RyaW5nO1xyXG59O1xyXG5cclxuaXNCb29sZWFuID0gZnVuY3Rpb24obykge1xyXG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ2Jvb2xlYW4nIHx8IG8gaW5zdGFuY2VvZiBCb29sZWFuO1xyXG59O1xyXG5cclxuaXNOdW1iZXIgPSBmdW5jdGlvbihvKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnbnVtYmVyJyB8fCBvIGluc3RhbmNlb2YgTnVtYmVyO1xyXG59O1xyXG5cclxuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG8pIHtcclxuICByZXR1cm4gdHlwZW9mIG8gPT09ICdmdW5jdGlvbic7XHJcbn07XHJcblxyXG5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uKG8pIHtcclxuICByZXR1cm4gL3N0cmluZ3xudW1iZXJ8Ym9vbGVhbi8udGVzdCh0eXBlb2Ygbyk7XHJcbn07XHJcblxyXG5pc0RlZmluZWQgPSBmdW5jdGlvbihvKSB7XHJcbiAgcmV0dXJuIG8gIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwO1xyXG59O1xyXG5cclxuaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvKSB7XHJcbiAgcmV0dXJuIG8gPT09IG51bGwgfHwgbyA9PT0gdm9pZCAwO1xyXG59O1xyXG5cclxuaXNBcnJheSA9IGZ1bmN0aW9uKG8pIHtcclxuICByZXR1cm4gbyBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxufTtcclxuXHJcbmlzT2JqZWN0ID0gZnVuY3Rpb24obykge1xyXG4gIHJldHVybiBvID09PSBPYmplY3QobykgJiYgdHlwZW9mIG8gIT09ICdmdW5jdGlvbic7XHJcbn07XHJcblxyXG50eXBlT2YgPSBmdW5jdGlvbihvKSB7XHJcbiAgaWYgKG8gPT09IG51bGwpIHtcclxuICAgIHJldHVybiAnbnVsbCc7XHJcbiAgfVxyXG4gIGlmIChpc0FycmF5KG8pKSB7XHJcbiAgICByZXR1cm4gJ2FycmF5JztcclxuICB9XHJcbiAgcmV0dXJuIHR5cGVvZiBvO1xyXG59O1xyXG5cclxubWl4aW4gPSBmdW5jdGlvbigpIHtcclxuICB2YXIgaywgbywgb2JqLCBvYmpzLCB2LCBfaSwgX2xlbjtcclxuICBvID0gYXJndW1lbnRzWzBdLCBvYmpzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcclxuICBpZiAobyA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSBvYmplY3QgYXMgYW4gYXJndW1lbnQuJyk7XHJcbiAgfVxyXG4gIGZvciAoX2kgPSAwLCBfbGVuID0gb2Jqcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xyXG4gICAgb2JqID0gb2Jqc1tfaV07XHJcbiAgICBmb3IgKGsgaW4gb2JqKSB7XHJcbiAgICAgIGlmICghX19oYXNQcm9wLmNhbGwob2JqLCBrKSkgY29udGludWU7XHJcbiAgICAgIHYgPSBvYmpba107XHJcbiAgICAgIGlmIChpc0RlZmluZWQob2JqKSkge1xyXG4gICAgICAgIG9ba10gPSBvYmpba107XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG87XHJcbn07XHJcblxyXG5hZGhlcmVzVG8gPSBmdW5jdGlvbihvLCBpbnRlcmZjZSkge1xyXG4gIHZhciBrLCB2O1xyXG4gIGlmICgoaXNPYmplY3QobykgfHwgaXNGdW5jdGlvbihvKSB8fCBpc0FycmF5KG8pKSAmJiAoaXNPYmplY3QoaW50ZXJmY2UpIHx8IGlzRnVuY3Rpb24oaW50ZXJmY2UpIHx8IGlzQXJyYXkoaW50ZXJmY2UpKSkge1xyXG4gICAgZm9yIChrIGluIGludGVyZmNlKSB7XHJcbiAgICAgIGlmICghX19oYXNQcm9wLmNhbGwoaW50ZXJmY2UsIGspKSBjb250aW51ZTtcclxuICAgICAgdiA9IGludGVyZmNlW2tdO1xyXG4gICAgICBpZiAoaW50ZXJmY2Vba10gPT09ICcqJykge1xyXG4gICAgICAgIGlmIChvW2tdID09PSB2b2lkIDApIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCEodHlwZU9mKG9ba10pID09PSB0eXBlT2YoaW50ZXJmY2Vba10pIHx8IHR5cGVPZihvW2tdKSA9PT0gaW50ZXJmY2Vba10pKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHR5cGVPZihvKSA9PT0gdHlwZU9mKGludGVyZmNlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGNyZWF0ZTogY3JlYXRlLFxyXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcclxuICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcclxuICBpc051bWJlcjogaXNOdW1iZXIsXHJcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcclxuICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXHJcbiAgaXNEZWZpbmVkOiBpc0RlZmluZWQsXHJcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxyXG4gIGlzQXJyYXk6IGlzQXJyYXksXHJcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxyXG4gIHR5cGVPZjogdHlwZU9mLFxyXG4gIG1peGluOiBtaXhpbixcclxuICBhZGhlcmVzVG86IGFkaGVyZXNUbyxcclxuICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgY3JlYXRlOiBjay5ja1xyXG4gIH1cclxufTtcclxuIl19
